#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    gyro,           sensorGyro)
#pragma config(Sensor, dgtl1,  leftLauncher,   sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  rightLauncher,  sensorQuadEncoder)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_3,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_4,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port2,           rightFrontMotor, tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_3)
#pragma config(Motor,  port3,           leftFrontMotor, tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_4)
#pragma config(Motor,  port4,           beltMotor,     tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           leftRearMotor, tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port6,           rightRearMotor, tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_2)
#pragma config(Motor,  port7,           intakeMotor,   tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port8,           launcherLeftMotor, tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port9,           launcherRightMotor, tmotorVex393HighSpeed_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////
// Rotate toward the goal to the left
void rotate()
{
	//Completely clear out any previous sensor readings by setting the port to "sensorNone"
	SensorType[gyro] = sensorNone;
	wait1Msec(1000);
	//Reconfigure Analog Port 8 as a Gyro sensor and allow time for ROBOTC to calibrate it
	SensorType[gyro] = sensorGyro;
	wait1Msec(2000);

	//Adjust SensorScale to correct the scaling for your gyro
	//SensorScale[gyro] = 260;
	//Adjust SensorFullCount to set the "rollover" point. 3600 sets the rollover point to +/-3600
	//SensorFullCount[gyro] = 3600;

	//Specify the number of degrees for the robot to turn (1 degree = 10, or 900 = 90 degrees)
	int degrees10 = 900;

	//While the absolute value of the gyro is less than the desired rotation...
	while(abs(SensorValue[gyro]) < degrees10)
	{
		//...continue turning
		motor[rightRearMotor] = 25;
		motor[rightFrontMotor] = 25;
		motor[leftRearMotor] = -25;
		motor[leftFrontMotor] = -25;
	}

	//Brief brake to stop some drift
	motor[rightRearMotor] = 5;
	motor[rightFrontMotor] = 5;
	motor[leftRearMotor] = -5;
	motor[leftFrontMotor] = -5;

	wait1Msec(250);
}

void rotate(int distance, int power)
{
	// Clear left and right encoders
	nMotorEncoder[rightFrontMotor] = 0;			// or resetMotorEncoder[rightFrontMotor];
	nMotorEncoder[rightRearMotor] = 0;
	nMotorEncoder[leftFrontMotor] = 0;
	nMotorEncoder[leftRearMotor] = 0;

	// ********************** With the Integrated Encoders, one full rotation equals 627 counts.

	int value = 250;
	// Power motors while all motors are less than value
	while( ((nMotorEncoder[leftRearMotor] < distance) && (nMotorEncoder[leftFrontMotor]) < distance) &&
		((nMotorEncoder[rightFrontMotor] < distance) && (nMotorEncoder[rightRearMotor]) < distance))
	{
		motor[rightFrontMotor] = power;
		motor[rightRearMotor] = power;

		motor[leftFrontMotor] = -power;
		motor[leftRearMotor] = -power;
	}

	// Turn motors off
	motor[rightFrontMotor] = 0;
	motor[rightRearMotor] = 0;
	motor[leftFrontMotor] = 0;
	motor[leftRearMotor] = 0;

}



void drive(int value, int power)
{
	// Clear left and right encoders
	nMotorEncoder[rightFrontMotor] = 0;			// or resetMotorEncoder[rightFrontMotor];
	nMotorEncoder[rightRearMotor] = 0;
	nMotorEncoder[leftFrontMotor] = 0;
	nMotorEncoder[leftRearMotor] = 0;

	// ********************** With the Integrated Encoders, one full rotation equals 627 counts.

	// Power motors while all motors are less than value
	while( ((nMotorEncoder[leftRearMotor] < value) && (nMotorEncoder[leftFrontMotor]) < value) &&
		((nMotorEncoder[rightFrontMotor] < value) && (nMotorEncoder[rightRearMotor]) < value))
	{
		motor[rightFrontMotor] = power;
		motor[rightRearMotor] = power;

		motor[leftFrontMotor] = power;
		motor[leftRearMotor] = power;
	}

	// Turn motors off
	motor[rightFrontMotor] = 0;
	motor[rightRearMotor] = 0;
	motor[leftFrontMotor] = 0;
	motor[leftRearMotor] = 0;
}

void pre_auton()
{
	// Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
	// Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
	bStopTasksBetweenModes = true;

	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task autonomous()
{
	motor[launcherLeftMotor] = 65;
	motor[launcherRightMotor] = 65;

	wait1Msec(1000);
	drive(100, 100);

	rotate();

	wait1Msec(5000);

	motor[intakeMotor] = 127;
	wait1Msec(1000);
	motor[intakeMotor] = 0;

	motor[intakeMotor] = 127;
	wait1Msec(1000);
	motor[intakeMotor] = 0;

	motor[intakeMotor] = 127;
	wait1Msec(1000);
	motor[intakeMotor] = 0;

	motor[intakeMotor] = 127;

	wait1Msec(10000);

	//...suck in balls.
	motor[beltMotor] = 127;

	drive(500, 100);

	drive(-500, -100);


}


/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task usercontrol()
{
	int threshold = 10;
	int Btn5UToggleState = 0;
	int Btn5UPressed = 0;
	int Btn5DToggleState = 0;
	int Btn5DPressed = 0;
	int Btn7UToggleState = 0;
	int Btn7UPressed = 0;
	int Btn7DToggleState = 0;
	int Btn7DPressed = 0;
	int speed = 70;

	motor[launcherLeftMotor] = speed;					//...activate launchers.
	motor[launcherRightMotor] = speed;

	while(1 == 1)
	{

		// DRIVE CONTROL - Tank drive style.
		//*******************************************************************
		//Right side of the robot is controlled by the right joystick, Y-axis
		if (abs(vexRT[Ch2]) > threshold)
		{
			motor[rightFrontMotor] = vexRT[Ch2];
			motor[rightRearMotor] = vexRT[Ch2];
		}
		else
		{
			motor[rightFrontMotor] = 0;
			motor[rightRearMotor] = 0;
		}

		//Left side of the robot is controlled by the left joystick, Y-axis
		if (abs(vexRT[Ch3]) > threshold)
		{
			motor[leftFrontMotor] = vexRT[Ch3];
			motor[leftRearMotor] = vexRT[Ch3];
		}
		else
		{
			motor[leftFrontMotor] = 0;
			motor[leftRearMotor] = 0;
		}
		//*******************************************************************


		// BALL LAUNCHER CONTROL - Shoots balls into goal.
		//*******************************************************************
		if (vexRT[Btn5U] == 1)
		{
			if (!Btn5UPressed)
			{
				Btn5UToggleState = 1 - Btn5UToggleState;
				Btn5UPressed = 1;
			}
		}
		else
		{
			Btn5UPressed = 0;
		}

		if (vexRT[Btn8D])												// BOOST
		{
			motor[launcherLeftMotor] = 127;
			motor[launcherRightMotor] = 127;
		}
		else if (Btn5UToggleState)							// DEFAULT SPEED
		{
			motor[launcherLeftMotor] = speed;					//...activate launchers.
			motor[launcherRightMotor] = speed;
		}
		else
		{
			motor[launcherLeftMotor] = 0;						//...deactivate launchers.
			motor[launcherRightMotor] = 0;
		}
		//*******************************************************************


		//=========================================

		// increase speed
		if (vexRT[Btn7U] == 1)
		{
			if (!Btn7UPressed)
			{
				Btn7UToggleState = 1 - Btn7UToggleState;
				Btn7UPressed = 1;
				if (Btn7UToggleState == 1)
				{
					speed = speed + 3;
				}
			}
		}
		else
		{
			Btn7UPressed = 0;
		}


		// decrease speed
		if (vexRT[Btn7D] == 1)
		{
			if (!Btn7DPressed)
			{
				Btn7DToggleState = 1 - Btn7DToggleState;
				Btn7DPressed = 1;
				if (Btn7DToggleState == 1)
				{
					speed = speed - 3;
				}
			}
		}
		else
		{
			Btn7DPressed = 0;
		}


		// DEFUALT SPEED
		if (vexRT[Btn8U])
		{
			speed = 75;
		}



		/*

		// FRONT ROLLER CONTROL - "Sucks up" balls and feeds to chain intake.
		//*******************************************************************

		if (vexRT[Btn5D] == 1)										//If Button 5D is pressed...
		{
		if (!Btn5DPressed)
		{
		Btn5DToggleState = 1 - Btn5DToggleState;							//...change toggle state.
		Btn5DPressed = 1;									//...note button was pressed.
		}
		}
		else
		{
		//Btn5DToggleState = false;
		Btn5DPressed = 0;
		}

		if (Btn5DToggleState)											//If toggle state is true...
		{								//...suck in balls.
		motor[beltMotor] = 127;
		}
		else																			//If toggle state is false...
		{
		//...deactivate.
		motor[beltMotor] = 0;
		}

		//*******************************************************************
		*/

		// CHAIN INTAKE CONTROL - Lifts/stores balls and feeds to launcher.
		//*******************************************************************
		if (vexRT[Btn6U] == 1)				//If Button 6U is held...
		{
			motor[intakeMotor] = 127;		//...intake balls.
			motor[beltMotor] = 127;
		}
		else if (vexRT[Btn6D] == 1)		//If Button 6D is held...
		{
			motor[intakeMotor] = -127;	//...eject balls.
			motor[beltMotor] = -127;
		}
		else													//Else (neither button is held)...
		{
			motor[intakeMotor] = 0;			//...stop.
			motor[beltMotor] = 0;
		}
		//*******************************************************************
	}
}