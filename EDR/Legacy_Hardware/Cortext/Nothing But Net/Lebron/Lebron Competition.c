#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           rightRearMotor, tmotorVex393_HBridge, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port2,           leftRearMotor, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           launcherRightMotor, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           launcherLeftMotor, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           rightFrontMotor, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           leftFrontMotor, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           intakeMotor1,  tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           intakeMotor2,  tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////

void pre_auton()
{
	// Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
	// Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
	bStopTasksBetweenModes = true;

	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...
}

void drive(int distance, int power)
{
	// Clear left and right encoders
	nMotorEncoder[rightFrontMotor] = 0;			// or resetMotorEncoder[rightFrontMotor];
	nMotorEncoder[rightRearMotor] = 0;
	nMotorEncoder[leftFrontMotor] = 0;
	nMotorEncoder[leftRearMotor] = 0;

	// ********************** With the Integrated Encoders, one full rotation equals 627 counts.

	// Power motors while all motors are less than value
	while( ((nMotorEncoder[leftRearMotor] < distance) && (nMotorEncoder[leftFrontMotor]) < distance) &&
		((nMotorEncoder[rightFrontMotor] < distance) && (nMotorEncoder[rightRearMotor]) < distance))
	{
		motor[rightFrontMotor] = power;
		motor[rightRearMotor] = power;

		motor[leftFrontMotor] = power;
		motor[leftRearMotor] = power;
	}

	// Turn motors off
	motor[rightFrontMotor] = 0;
	motor[rightRearMotor] = 0;
	motor[leftFrontMotor] = 0;
	motor[leftRearMotor] = 0;
}

void rotate()
{
	// Clear left and right encoders
	// or resetMotorEncoder[rightFrontMotor];
	nMotorEncoder[rightRearMotor] = 0;

	// ********************** With the Integrated Encoders, one full rotation equals 627 counts.

	int value = 250;
	// Power motors while all motors are less than value
	while((nMotorEncoder[rightRearMotor]) < value)
	{
		motor[rightFrontMotor] = 100;
		motor[rightRearMotor] = 100;

		motor[leftFrontMotor] = -100;
		motor[leftRearMotor] = -100;
	}

	// Turn motors off
	motor[rightFrontMotor] = 0;
	motor[rightRearMotor] = 0;
	motor[leftFrontMotor] = 0;
	motor[leftRearMotor] = 0;

}

void rotate(int distance)
{
	// Clear left and right encoders
	// or resetMotorEncoder[rightFrontMotor];
	nMotorEncoder[rightRearMotor] = 0;

	// ********************** With the Integrated Encoders, one full rotation equals 627 counts.

	// Power motors while all motors are less than value
	while((nMotorEncoder[rightRearMotor]) < distance)
	{
		motor[rightFrontMotor] = 100;
		motor[rightRearMotor] = 100;

		motor[leftFrontMotor] = -100;
		motor[leftRearMotor] = -100;
	}

	// Turn motors off
	motor[rightFrontMotor] = 0;
	motor[rightRearMotor] = 0;
	motor[leftFrontMotor] = 0;
	motor[leftRearMotor] = 0;

}

// Rotation based on power and distance
void rotate(int distance, int power)
{
	// Clear left and right encoders
	// or resetMotorEncoder[rightFrontMotor];
	nMotorEncoder[rightRearMotor] = 0;

	// ********************** With the Integrated Encoders, one full rotation equals 627 counts.

	// Power motors while all motors are less than value
	while((nMotorEncoder[rightRearMotor]) < distance)
	{
		motor[rightFrontMotor] = power;
		motor[rightRearMotor] = power;

		motor[leftFrontMotor] = -power;
		motor[leftRearMotor] = -power;
	}

	// Turn motors off
	motor[rightFrontMotor] = 0;
	motor[rightRearMotor] = 0;
	motor[leftFrontMotor] = 0;
	motor[leftRearMotor] = 0;

}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task autonomous()
{
	while(true)
	{
		motor[launcherLeftMotor] = 100;
		motor[launcherRightMotor] = 100;


		motor[intakeMotor1] = 127;		//...intake balls.
		motor[intakeMotor2] = 127;
		drive(150, 100);	//Drive distance 150 at power 100
		rotate(750, 100); //Rotate 1000 at power 100


	}
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task usercontrol()
{
	int threshold = 10;
	int Btn5UToggleState = 0;
	int Btn5UPressed = 0;
	int Btn5DToggleState = 0;
	int Btn5DPressed = 0;
	int Btn7UToggleState = 0;
	int Btn7UPressed = 0;
	int Btn7DToggleState = 0;
	int Btn7DPressed = 0;
	int speed = 60;



	while(1 == 1)
	{

		// DRIVE CONTROL - Tank drive style.
		//*******************************************************************
		//Right side of the robot is controlled by the right joystick, Y-axis
		if (abs(vexRT[Ch2]) > threshold)
		{
			motor[rightFrontMotor] = vexRT[Ch2];
			motor[rightRearMotor] = vexRT[Ch2];
		}
		else
		{
			motor[rightFrontMotor] = 0;
			motor[rightRearMotor] = 0;
		}

		//Left side of the robot is controlled by the left joystick, Y-axis
		if (abs(vexRT[Ch3]) > threshold)
		{
			motor[leftFrontMotor] = vexRT[Ch3];
			motor[leftRearMotor] = vexRT[Ch3];
		}
		else
		{
			motor[leftFrontMotor] = 0;
			motor[leftRearMotor] = 0;
		}
		//*******************************************************************


		// BALL LAUNCHER CONTROL - Shoots balls into goal.
		//*******************************************************************

		// BALL LAUNCHER CONTROL - Shoots balls into goal.
		//*******************************************************************
		if (vexRT[Btn5U] == 1)
		{
			if (!Btn5UPressed)
			{
				Btn5UToggleState = 1 - Btn5UToggleState;
				Btn5UPressed = 1;
			}
		}
		else
		{
			Btn5UPressed = 0;
		}


		if (vexRT[Btn8D])												// BOOST
		{
			motor[launcherLeftMotor] = 127;
			motor[launcherRightMotor] = 127;
		}
		else if (Btn5UToggleState)							// DEFAULT SPEED
		{
			motor[launcherLeftMotor] = speed;					//...activate launchers.
			motor[launcherRightMotor] = speed;
		}
		else
		{
			motor[launcherLeftMotor] = 0;						//...deactivate launchers.
			motor[launcherRightMotor] = 0;
		}
		//*******************************************************************


		//=========================================

		// increase speed
		if (vexRT[Btn7U] == 1)
		{
			if (!Btn7UPressed)
			{
				Btn7UToggleState = 1 - Btn7UToggleState;
				Btn7UPressed = 1;
				if (Btn7UToggleState == 1)
				{
					speed = speed + 3;
				}
			}
		}
		else
		{
			Btn7UPressed = 0;
		}


		// decrease speed
		if (vexRT[Btn7D] == 1)
		{
			if (!Btn7DPressed)
			{
				Btn7DToggleState = 1 - Btn7DToggleState;
				Btn7DPressed = 1;
				if (Btn7DToggleState == 1)
				{
					speed = speed - 3;
				}
			}
		}
		else
		{
			Btn7DPressed = 0;
		}


		// DEFAULT SPEED
		if (vexRT[Btn8U])
		{
			speed = 60;
		}






		// CHAIN INTAKE CONTROL - Lifts/stores balls and feeds to launcher.
		//*******************************************************************
		if (vexRT[Btn6U] == 1)				//If Button 6U is held...
		{
			motor[intakeMotor1] = 127;		//...intake balls.
			motor[intakeMotor2] = 127;
		}
		else if (vexRT[Btn6D] == 1)		//If Button 6D is held...
		{
			motor[intakeMotor1] = -127;	//...eject balls.
			motor[intakeMotor2] = -127;
		}
		else													//Else (neither button is held)...
		{
			motor[intakeMotor1] = 0;			//...stop.
			motor[intakeMotor2] = 0;
		}
		//*******************************************************************
	}
}
